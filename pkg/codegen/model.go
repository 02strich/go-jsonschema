package codegen

import (
	"strings"

	"github.com/sanity-io/litter"
)

type Decl interface {
	Generate(out *Emitter)
}

type File struct {
	FileName string
	Package  Package
}

// func (File) isDecl() {}
func (p *File) Generate(out *Emitter) {
	out.Comment("THIS FILE IS AUTOMATICALLY GENERATED. EDITING IS NOT ADVISABLE.")
	out.Newline()
	p.Package.Generate(out)
}

// Package is a "package <name>; <body>".
type Package struct {
	QualifiedName string
	Comment       string
	Decls         []Decl
	Imports       []Import
}

// func (Package) isDecl() {}
func (p *Package) AddDecl(t Decl) {
	p.Decls = append(p.Decls, t)
}

func (p *Package) AddImport(t Import) {
	p.Imports = append(p.Imports, t)
}

func (p *Package) Name() string {
	s := p.QualifiedName
	if i := strings.LastIndex(s, "/"); i != -1 && i < len(s)-1 {
		return s[i+1:]
	}
	return s
}

func (p *Package) Generate(out *Emitter) {
	out.Comment(p.Comment)
	out.Println("package %s", p.Name())
	if len(p.Imports) > 0 {
		// out.Println("(")
		// out.Indent(1)
		out.Newline()
		for _, i := range p.Imports {
			i.Generate(out)
		}
		// out.Indent(-1)
		// out.Println(")")
	}
	out.Newline()
	for i, t := range p.Decls {
		if i > 0 {
			out.Newline()
		}
		t.Generate(out)
	}
}

// Constant is a "const <name> = <value>".
type Constant struct {
	Type  Type
	Name  string
	Value interface{}
}

// func (Constant) isDecl() {}
func (e *Constant) Generate(out *Emitter) {
	out.Print("const %s ", e.Name)
	e.Type.Generate(out)
	out.Print(" = %s", litter.Sdump(e.Value))
}

// Fragment is an arbitary piece of code.
type Fragment func(*Emitter)

func (f Fragment) Generate(out *Emitter) {
	f(out)
}

// Method defines a method and how to generate it.
type Method struct {
	Impl func(*Emitter)
}

// func (Method) isDecl() {}
func (m *Method) Generate(out *Emitter) {
	out.Newline()
	m.Impl(out)
	out.Newline()
}

// Import is a "type <name> = <definition>".
type Import struct {
	Name          string
	QualifiedName string
}

func (i *Import) Generate(out *Emitter) {
	out.Println("import %s %q", i.Name, i.QualifiedName)
}

// TypeDecl is a "type <name> = <definition>".
type TypeDecl struct {
	Name    string
	Type    Type
	Comment string
}

// func (TypeDecl) isDecl() {}

// func (td *TypeDecl) UseDecl() string { return td.Name }
func (td *TypeDecl) Generate(out *Emitter) {
	out.Comment(td.Comment)
	out.Print("type %s ", td.Name)
	td.Type.Generate(out)
}

type Type interface {
	Decl
	IsNillable() bool
}

type PointerType struct {
	Type Type
}

func (PointerType) IsNillable() bool { return true }

func (p PointerType) Generate(out *Emitter) {
	out.Print("*")
	p.Type.Generate(out)
}

type ArrayType struct {
	Type Type
}

func (ArrayType) IsNillable() bool { return true }

// func (p ArrayType) UseDecl() string { return fmt.Sprintf("[]%s", p.Type) }
func (p ArrayType) Generate(out *Emitter) {
	out.Print("[]")
	p.Type.Generate(out)
}

type NamedType struct {
	Decl *TypeDecl
}

func (t NamedType) IsNillable() bool {
	return t.Decl.Type.IsNillable()
}

func (t NamedType) Generate(out *Emitter) {
	out.Print(t.Decl.Name)
}

type PrimitiveType struct {
	Type string
}

func (PrimitiveType) IsNillable() bool { return false }

// func (p PrimitiveType) UseDecl() string { return p.Type }
func (p PrimitiveType) Generate(out *Emitter) {
	out.Print(p.Type)
}

type MapType struct {
	KeyType, ValueType Type
}

func (MapType) IsNillable() bool { return true }

// func (p MapType) UseDecl() string { return p.Type }
func (p MapType) Generate(out *Emitter) {
	out.Print("map[")
	p.KeyType.Generate(out)
	out.Print("]")
	p.ValueType.Generate(out)
}

type EmptyInterfaceType struct{}

func (EmptyInterfaceType) IsNillable() bool { return true }

// func (EmptyInterfaceType) UseDecl() string { return "interface{}" }
func (EmptyInterfaceType) Generate(out *Emitter) {
	out.Print("interface{}")
}

type StructType struct {
	Fields []StructField
}

func (StructType) IsNillable() bool { return false }

func (s *StructType) AddField(f StructField) {
	s.Fields = append(s.Fields, f)
}

func (s *StructType) Generate(out *Emitter) {
	out.Println("struct {")
	out.Indent(1)
	i := 0
	for _, f := range s.Fields {
		if !f.Synthetic {
			if i > 0 {
				out.Newline()
			}
			f.Generate(out)
			i++
		}
	}
	out.Indent(-1)
	out.Println("}")
}

type StructField struct {
	Name       string
	Type       Type
	Comment    string
	Tags       string
	IsRequired bool
	JSONName   string
	Synthetic  bool
	Rules      []Rule
}

func (f *StructField) AddRule(rule Rule) {
	f.Rules = append(f.Rules, rule)
}

func (f *StructField) Generate(out *Emitter) {
	out.Comment(f.Comment)
	out.Print("%s ", f.Name)
	f.Type.Generate(out)
	if f.Tags != "" {
		out.Print(" `%s`", f.Tags)
	}
	out.Newline()
}
